{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/exposePolyDecomp.ts","webpack:///./node_modules/poly-decomp/src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","poly_decomp__WEBPACK_IMPORTED_MODULE_0__","poly_decomp__WEBPACK_IMPORTED_MODULE_0___default","window","decomp","a","lineInt","l1","l2","precision","a1","b1","c1","a2","b2","c2","det","scalar_eq","lineSegmentsIntersect","p1","p2","q1","q2","dx","dy","da","db","triangleArea","b","isLeft","isLeftOn","isRight","isRightOn","polygon","edges","polygonGetCutEdges","min","tmp1","tmp2","tmpPoly","nDiags","Number","MAX_VALUE","length","polygonIsReflex","j","polygonCanSee","polygonCopy","k","push","polygonAt","polygonSlice","cutEdges","Array","polys","cutEdge","poly","result","splice","indexOf","quickDecomp","polygonQuickDecomp","reflexVertices","steinerPoints","delta","maxlevel","level","upperInt","lowerInt","upperDist","lowerDist","closestDist","upperIndex","lowerIndex","closestIndex","lowerPoly","upperPoly","v","console","warn","getIntersectionPoint","sqdist","polygonAppend","polygonCanSee2","isSimple","path","removeCollinearPoints","num","collinear","removeDuplicatePoints","pi","points_eq","makeCCW","br","tmp","N","pop","polygonReverse","tmpPoint1","tmpPoint2","thresholdAngle","ab","bc","dot","magA","Math","sqrt","magB","acos","from","to","tmpLine1","tmpLine2","dist","targetPoly","polygonClear","abs"],"mappings":"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","file":"exposePolyDecomp.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 193);\n","// @ts-ignore\nimport decomp from 'poly-decomp';\n\n// @ts-ignore\nwindow.decomp = decomp;\n","module.exports = {\n    decomp: polygonDecomp,\n    quickDecomp: polygonQuickDecomp,\n    isSimple: polygonIsSimple,\n    removeCollinearPoints: polygonRemoveCollinearPoints,\n    removeDuplicatePoints: polygonRemoveDuplicatePoints,\n    makeCCW: polygonMakeCCW\n};\n\n/**\n * Compute the intersection between two lines.\n * @static\n * @method lineInt\n * @param  {Array}  l1          Line vector 1\n * @param  {Array}  l2          Line vector 2\n * @param  {Number} precision   Precision to use when checking if the lines are parallel\n * @return {Array}              The intersection point.\n */\nfunction lineInt(l1,l2,precision){\n    precision = precision || 0;\n    var i = [0,0]; // point\n    var a1, b1, c1, a2, b2, c2, det; // scalars\n    a1 = l1[1][1] - l1[0][1];\n    b1 = l1[0][0] - l1[1][0];\n    c1 = a1 * l1[0][0] + b1 * l1[0][1];\n    a2 = l2[1][1] - l2[0][1];\n    b2 = l2[0][0] - l2[1][0];\n    c2 = a2 * l2[0][0] + b2 * l2[0][1];\n    det = a1 * b2 - a2*b1;\n    if (!scalar_eq(det, 0, precision)) { // lines are not parallel\n        i[0] = (b2 * c1 - b1 * c2) / det;\n        i[1] = (a1 * c2 - a2 * c1) / det;\n    }\n    return i;\n}\n\n/**\n * Checks if two line segments intersects.\n * @method segmentsIntersect\n * @param {Array} p1 The start vertex of the first line segment.\n * @param {Array} p2 The end vertex of the first line segment.\n * @param {Array} q1 The start vertex of the second line segment.\n * @param {Array} q2 The end vertex of the second line segment.\n * @return {Boolean} True if the two line segments intersect\n */\nfunction lineSegmentsIntersect(p1, p2, q1, q2){\n\tvar dx = p2[0] - p1[0];\n\tvar dy = p2[1] - p1[1];\n\tvar da = q2[0] - q1[0];\n\tvar db = q2[1] - q1[1];\n\n\t// segments are parallel\n\tif((da*dy - db*dx) === 0){\n\t\treturn false;\n\t}\n\n\tvar s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);\n\tvar t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);\n\n\treturn (s>=0 && s<=1 && t>=0 && t<=1);\n}\n\n/**\n * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.\n * @static\n * @method area\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @return {Number}\n */\nfunction triangleArea(a,b,c){\n    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));\n}\n\nfunction isLeft(a,b,c){\n    return triangleArea(a,b,c) > 0;\n}\n\nfunction isLeftOn(a,b,c) {\n    return triangleArea(a, b, c) >= 0;\n}\n\nfunction isRight(a,b,c) {\n    return triangleArea(a, b, c) < 0;\n}\n\nfunction isRightOn(a,b,c) {\n    return triangleArea(a, b, c) <= 0;\n}\n\nvar tmpPoint1 = [],\n    tmpPoint2 = [];\n\n/**\n * Check if three points are collinear\n * @method collinear\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.\n * @return {Boolean}\n */\nfunction collinear(a,b,c,thresholdAngle) {\n    if(!thresholdAngle){\n        return triangleArea(a, b, c) === 0;\n    } else {\n        var ab = tmpPoint1,\n            bc = tmpPoint2;\n\n        ab[0] = b[0]-a[0];\n        ab[1] = b[1]-a[1];\n        bc[0] = c[0]-b[0];\n        bc[1] = c[1]-b[1];\n\n        var dot = ab[0]*bc[0] + ab[1]*bc[1],\n            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),\n            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),\n            angle = Math.acos(dot/(magA*magB));\n        return angle < thresholdAngle;\n    }\n}\n\nfunction sqdist(a,b){\n    var dx = b[0] - a[0];\n    var dy = b[1] - a[1];\n    return dx * dx + dy * dy;\n}\n\n/**\n * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.\n * @method at\n * @param  {Number} i\n * @return {Array}\n */\nfunction polygonAt(polygon, i){\n    var s = polygon.length;\n    return polygon[i < 0 ? i % s + s : i % s];\n}\n\n/**\n * Clear the polygon data\n * @method clear\n * @return {Array}\n */\nfunction polygonClear(polygon){\n    polygon.length = 0;\n}\n\n/**\n * Append points \"from\" to \"to\"-1 from an other polygon \"poly\" onto this one.\n * @method append\n * @param {Polygon} poly The polygon to get points from.\n * @param {Number}  from The vertex index in \"poly\".\n * @param {Number}  to The end vertex index in \"poly\". Note that this vertex is NOT included when appending.\n * @return {Array}\n */\nfunction polygonAppend(polygon, poly, from, to){\n    for(var i=from; i<to; i++){\n        polygon.push(poly[i]);\n    }\n}\n\n/**\n * Make sure that the polygon vertices are ordered counter-clockwise.\n * @method makeCCW\n */\nfunction polygonMakeCCW(polygon){\n    var br = 0,\n        v = polygon;\n\n    // find bottom right point\n    for (var i = 1; i < polygon.length; ++i) {\n        if (v[i][1] < v[br][1] || (v[i][1] === v[br][1] && v[i][0] > v[br][0])) {\n            br = i;\n        }\n    }\n\n    // reverse poly if clockwise\n    if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {\n        polygonReverse(polygon);\n        return true;\n    } else {\n        return false;\n    }\n}\n\n/**\n * Reverse the vertices in the polygon\n * @method reverse\n */\nfunction polygonReverse(polygon){\n    var tmp = [];\n    var N = polygon.length;\n    for(var i=0; i!==N; i++){\n        tmp.push(polygon.pop());\n    }\n    for(var i=0; i!==N; i++){\n\t\tpolygon[i] = tmp[i];\n    }\n}\n\n/**\n * Check if a point in the polygon is a reflex point\n * @method isReflex\n * @param  {Number}  i\n * @return {Boolean}\n */\nfunction polygonIsReflex(polygon, i){\n    return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));\n}\n\nvar tmpLine1=[],\n    tmpLine2=[];\n\n/**\n * Check if two vertices in the polygon can see each other\n * @method canSee\n * @param  {Number} a Vertex index 1\n * @param  {Number} b Vertex index 2\n * @return {Boolean}\n */\nfunction polygonCanSee(polygon, a,b) {\n    var p, dist, l1=tmpLine1, l2=tmpLine2;\n\n    if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {\n        return false;\n    }\n    dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));\n    for (var i = 0; i !== polygon.length; ++i) { // for each edge\n        if ((i + 1) % polygon.length === a || i === a){ // ignore incident edges\n            continue;\n        }\n        if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) { // if diag intersects an edge\n            l1[0] = polygonAt(polygon, a);\n            l1[1] = polygonAt(polygon, b);\n            l2[0] = polygonAt(polygon, i);\n            l2[1] = polygonAt(polygon, i + 1);\n            p = lineInt(l1,l2);\n            if (sqdist(polygonAt(polygon, a), p) < dist) { // if edge is blocking visibility to b\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n/**\n * Check if two vertices in the polygon can see each other\n * @method canSee2\n * @param  {Number} a Vertex index 1\n * @param  {Number} b Vertex index 2\n * @return {Boolean}\n */\nfunction polygonCanSee2(polygon, a,b) {\n    // for each edge\n    for (var i = 0; i !== polygon.length; ++i) {\n        // ignore incident edges\n        if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b){\n            continue;\n        }\n        if( lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i+1)) ){\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Copy the polygon from vertex i to vertex j.\n * @method copy\n * @param  {Number} i\n * @param  {Number} j\n * @param  {Polygon} [targetPoly]   Optional target polygon to save in.\n * @return {Polygon}                The resulting copy.\n */\nfunction polygonCopy(polygon, i,j,targetPoly){\n    var p = targetPoly || [];\n    polygonClear(p);\n    if (i < j) {\n        // Insert all vertices from i to j\n        for(var k=i; k<=j; k++){\n            p.push(polygon[k]);\n        }\n\n    } else {\n\n        // Insert vertices 0 to j\n        for(var k=0; k<=j; k++){\n            p.push(polygon[k]);\n        }\n\n        // Insert vertices i to end\n        for(var k=i; k<polygon.length; k++){\n            p.push(polygon[k]);\n        }\n    }\n\n    return p;\n}\n\n/**\n * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.\n * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.\n * @method getCutEdges\n * @return {Array}\n */\nfunction polygonGetCutEdges(polygon) {\n    var min=[], tmp1=[], tmp2=[], tmpPoly = [];\n    var nDiags = Number.MAX_VALUE;\n\n    for (var i = 0; i < polygon.length; ++i) {\n        if (polygonIsReflex(polygon, i)) {\n            for (var j = 0; j < polygon.length; ++j) {\n                if (polygonCanSee(polygon, i, j)) {\n                    tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));\n                    tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));\n\n                    for(var k=0; k<tmp2.length; k++){\n                        tmp1.push(tmp2[k]);\n                    }\n\n                    if (tmp1.length < nDiags) {\n                        min = tmp1;\n                        nDiags = tmp1.length;\n                        min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);\n                    }\n                }\n            }\n        }\n    }\n\n    return min;\n}\n\n/**\n * Decomposes the polygon into one or more convex sub-Polygons.\n * @method decomp\n * @return {Array} An array or Polygon objects.\n */\nfunction polygonDecomp(polygon){\n    var edges = polygonGetCutEdges(polygon);\n    if(edges.length > 0){\n        return polygonSlice(polygon, edges);\n    } else {\n        return [polygon];\n    }\n}\n\n/**\n * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.\n * @method slice\n * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()\n * @return {Array}\n */\nfunction polygonSlice(polygon, cutEdges){\n    if(cutEdges.length === 0){\n\t\treturn [polygon];\n    }\n    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length===2 && cutEdges[0][0] instanceof Array){\n\n        var polys = [polygon];\n\n        for(var i=0; i<cutEdges.length; i++){\n            var cutEdge = cutEdges[i];\n            // Cut all polys\n            for(var j=0; j<polys.length; j++){\n                var poly = polys[j];\n                var result = polygonSlice(poly, cutEdge);\n                if(result){\n                    // Found poly! Cut and quit\n                    polys.splice(j,1);\n                    polys.push(result[0],result[1]);\n                    break;\n                }\n            }\n        }\n\n        return polys;\n    } else {\n\n        // Was given one edge\n        var cutEdge = cutEdges;\n        var i = polygon.indexOf(cutEdge[0]);\n        var j = polygon.indexOf(cutEdge[1]);\n\n        if(i !== -1 && j !== -1){\n            return [polygonCopy(polygon, i,j),\n                    polygonCopy(polygon, j,i)];\n        } else {\n            return false;\n        }\n    }\n}\n\n/**\n * Checks that the line segments of this polygon do not intersect each other.\n * @method isSimple\n * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]\n * @return {Boolean}\n * @todo Should it check all segments with all others?\n */\nfunction polygonIsSimple(polygon){\n    var path = polygon, i;\n    // Check\n    for(i=0; i<path.length-1; i++){\n        for(var j=0; j<i-1; j++){\n            if(lineSegmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){\n                return false;\n            }\n        }\n    }\n\n    // Check the segment between the last and the first point to all others\n    for(i=1; i<path.length-2; i++){\n        if(lineSegmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction getIntersectionPoint(p1, p2, q1, q2, delta){\n\tdelta = delta || 0;\n\tvar a1 = p2[1] - p1[1];\n\tvar b1 = p1[0] - p2[0];\n\tvar c1 = (a1 * p1[0]) + (b1 * p1[1]);\n\tvar a2 = q2[1] - q1[1];\n\tvar b2 = q1[0] - q2[0];\n\tvar c2 = (a2 * q1[0]) + (b2 * q1[1]);\n\tvar det = (a1 * b2) - (a2 * b1);\n\n\tif(!scalar_eq(det,0,delta)){\n\t\treturn [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det];\n\t} else {\n\t\treturn [0,0];\n    }\n}\n\n/**\n * Quickly decompose the Polygon into convex sub-polygons.\n * @method quickDecomp\n * @param  {Array} result\n * @param  {Array} [reflexVertices]\n * @param  {Array} [steinerPoints]\n * @param  {Number} [delta]\n * @param  {Number} [maxlevel]\n * @param  {Number} [level]\n * @return {Array}\n */\nfunction polygonQuickDecomp(polygon, result,reflexVertices,steinerPoints,delta,maxlevel,level){\n    maxlevel = maxlevel || 100;\n    level = level || 0;\n    delta = delta || 25;\n    result = typeof(result)!==\"undefined\" ? result : [];\n    reflexVertices = reflexVertices || [];\n    steinerPoints = steinerPoints || [];\n\n    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points\n    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars\n    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers\n    var lowerPoly=[], upperPoly=[]; // polygons\n    var poly = polygon,\n        v = polygon;\n\n    if(v.length < 3){\n\t\treturn result;\n    }\n\n    level++;\n    if(level > maxlevel){\n        console.warn(\"quickDecomp: max level (\"+maxlevel+\") reached.\");\n        return result;\n    }\n\n    for (var i = 0; i < polygon.length; ++i) {\n        if (polygonIsReflex(poly, i)) {\n            reflexVertices.push(poly[i]);\n            upperDist = lowerDist = Number.MAX_VALUE;\n\n\n            for (var j = 0; j < polygon.length; ++j) {\n                if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) { // if line intersects with an edge\n                    p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection\n                    if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) { // make sure it's inside the poly\n                        d = sqdist(poly[i], p);\n                        if (d < lowerDist) { // keep only the closest intersection\n                            lowerDist = d;\n                            lowerInt = p;\n                            lowerIndex = j;\n                        }\n                    }\n                }\n                if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n                    p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));\n                    if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {\n                        d = sqdist(poly[i], p);\n                        if (d < upperDist) {\n                            upperDist = d;\n                            upperInt = p;\n                            upperIndex = j;\n                        }\n                    }\n                }\n            }\n\n            // if there are no vertices to connect to, choose a point in the middle\n            if (lowerIndex === (upperIndex + 1) % polygon.length) {\n                //console.log(\"Case 1: Vertex(\"+i+\"), lowerIndex(\"+lowerIndex+\"), upperIndex(\"+upperIndex+\"), poly.size(\"+polygon.length+\")\");\n                p[0] = (lowerInt[0] + upperInt[0]) / 2;\n                p[1] = (lowerInt[1] + upperInt[1]) / 2;\n                steinerPoints.push(p);\n\n                if (i < upperIndex) {\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);\n                    polygonAppend(lowerPoly, poly, i, upperIndex+1);\n                    lowerPoly.push(p);\n                    upperPoly.push(p);\n                    if (lowerIndex !== 0){\n                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());\n                        polygonAppend(upperPoly, poly,lowerIndex,poly.length);\n                    }\n                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);\n                    polygonAppend(upperPoly, poly,0,i+1);\n                } else {\n                    if (i !== 0){\n                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());\n                        polygonAppend(lowerPoly, poly,i,poly.length);\n                    }\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);\n                    polygonAppend(lowerPoly, poly,0,upperIndex+1);\n                    lowerPoly.push(p);\n                    upperPoly.push(p);\n                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);\n                    polygonAppend(upperPoly, poly,lowerIndex,i+1);\n                }\n            } else {\n                // connect to the closest point within the triangle\n                //console.log(\"Case 2: Vertex(\"+i+\"), closestIndex(\"+closestIndex+\"), poly.size(\"+polygon.length+\")\\n\");\n\n                if (lowerIndex > upperIndex) {\n                    upperIndex += polygon.length;\n                }\n                closestDist = Number.MAX_VALUE;\n\n                if(upperIndex < lowerIndex){\n                    return result;\n                }\n\n                for (var j = lowerIndex; j <= upperIndex; ++j) {\n                    if (\n                        isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) &&\n                        isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))\n                    ) {\n                        d = sqdist(polygonAt(poly, i), polygonAt(poly, j));\n                        if (d < closestDist && polygonCanSee2(poly, i, j)) {\n                            closestDist = d;\n                            closestIndex = j % polygon.length;\n                        }\n                    }\n                }\n\n                if (i < closestIndex) {\n                    polygonAppend(lowerPoly, poly,i,closestIndex+1);\n                    if (closestIndex !== 0){\n                        polygonAppend(upperPoly, poly,closestIndex,v.length);\n                    }\n                    polygonAppend(upperPoly, poly,0,i+1);\n                } else {\n                    if (i !== 0){\n                        polygonAppend(lowerPoly, poly,i,v.length);\n                    }\n                    polygonAppend(lowerPoly, poly,0,closestIndex+1);\n                    polygonAppend(upperPoly, poly,closestIndex,i+1);\n                }\n            }\n\n            // solve smallest poly first\n            if (lowerPoly.length < upperPoly.length) {\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n            } else {\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n            }\n\n            return result;\n        }\n    }\n    result.push(polygon);\n\n    return result;\n}\n\n/**\n * Remove collinear points in the polygon.\n * @method removeCollinearPoints\n * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.\n * @return {Number}           The number of points removed\n */\nfunction polygonRemoveCollinearPoints(polygon, precision){\n    var num = 0;\n    for(var i=polygon.length-1; polygon.length>3 && i>=0; --i){\n        if(collinear(polygonAt(polygon, i-1),polygonAt(polygon, i),polygonAt(polygon, i+1),precision)){\n            // Remove the middle point\n            polygon.splice(i%polygon.length,1);\n            num++;\n        }\n    }\n    return num;\n}\n\n/**\n * Remove duplicate points in the polygon.\n * @method removeDuplicatePoints\n * @param  {Number} [precision] The threshold to use when determining whether two points are the same. Use zero for best precision.\n */\nfunction polygonRemoveDuplicatePoints(polygon, precision){\n    for(var i=polygon.length-1; i>=1; --i){\n        var pi = polygon[i];\n        for(var j=i-1; j>=0; --j){\n            if(points_eq(pi, polygon[j], precision)){\n                polygon.splice(i,1);\n                continue;\n            }\n        }\n    }\n}\n\n/**\n * Check if two scalars are equal\n * @static\n * @method eq\n * @param  {Number} a\n * @param  {Number} b\n * @param  {Number} [precision]\n * @return {Boolean}\n */\nfunction scalar_eq(a,b,precision){\n    precision = precision || 0;\n    return Math.abs(a-b) <= precision;\n}\n\n/**\n * Check if two points are equal\n * @static\n * @method points_eq\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Number} [precision]\n * @return {Boolean}\n */\nfunction points_eq(a,b,precision){\n    return scalar_eq(a[0],b[0],precision) && scalar_eq(a[1],b[1],precision);\n}\n"],"sourceRoot":""}