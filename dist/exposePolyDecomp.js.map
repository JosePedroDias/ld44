{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/poly-decomp/src/index.js","webpack:///./src/exposePolyDecomp.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","lineInt","l1","l2","precision","a1","b1","c1","a2","b2","c2","det","scalar_eq","lineSegmentsIntersect","p1","p2","q1","q2","dx","dy","da","db","triangleArea","a","b","isLeft","isLeftOn","isRight","isRightOn","decomp","polygon","edges","polygonGetCutEdges","min","tmp1","tmp2","tmpPoly","nDiags","Number","MAX_VALUE","length","polygonIsReflex","j","polygonCanSee","polygonCopy","k","push","polygonAt","polygonSlice","cutEdges","Array","polys","cutEdge","poly","result","splice","indexOf","quickDecomp","polygonQuickDecomp","reflexVertices","steinerPoints","delta","maxlevel","level","upperInt","lowerInt","upperDist","lowerDist","closestDist","upperIndex","lowerIndex","closestIndex","lowerPoly","upperPoly","v","console","warn","getIntersectionPoint","sqdist","polygonAppend","polygonCanSee2","isSimple","path","removeCollinearPoints","num","collinear","removeDuplicatePoints","pi","points_eq","makeCCW","br","tmp","N","pop","polygonReverse","tmpPoint1","tmpPoint2","thresholdAngle","ab","bc","dot","magA","Math","sqrt","magB","acos","from","to","tmpLine1","tmpLine2","dist","targetPoly","polygonClear","abs","__webpack_exports__","poly_decomp__WEBPACK_IMPORTED_MODULE_0__","poly_decomp__WEBPACK_IMPORTED_MODULE_0___default","window"],"mappings":"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","file":"exposePolyDecomp.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","module.exports = {\n    decomp: polygonDecomp,\n    quickDecomp: polygonQuickDecomp,\n    isSimple: polygonIsSimple,\n    removeCollinearPoints: polygonRemoveCollinearPoints,\n    removeDuplicatePoints: polygonRemoveDuplicatePoints,\n    makeCCW: polygonMakeCCW\n};\n\n/**\n * Compute the intersection between two lines.\n * @static\n * @method lineInt\n * @param  {Array}  l1          Line vector 1\n * @param  {Array}  l2          Line vector 2\n * @param  {Number} precision   Precision to use when checking if the lines are parallel\n * @return {Array}              The intersection point.\n */\nfunction lineInt(l1,l2,precision){\n    precision = precision || 0;\n    var i = [0,0]; // point\n    var a1, b1, c1, a2, b2, c2, det; // scalars\n    a1 = l1[1][1] - l1[0][1];\n    b1 = l1[0][0] - l1[1][0];\n    c1 = a1 * l1[0][0] + b1 * l1[0][1];\n    a2 = l2[1][1] - l2[0][1];\n    b2 = l2[0][0] - l2[1][0];\n    c2 = a2 * l2[0][0] + b2 * l2[0][1];\n    det = a1 * b2 - a2*b1;\n    if (!scalar_eq(det, 0, precision)) { // lines are not parallel\n        i[0] = (b2 * c1 - b1 * c2) / det;\n        i[1] = (a1 * c2 - a2 * c1) / det;\n    }\n    return i;\n}\n\n/**\n * Checks if two line segments intersects.\n * @method segmentsIntersect\n * @param {Array} p1 The start vertex of the first line segment.\n * @param {Array} p2 The end vertex of the first line segment.\n * @param {Array} q1 The start vertex of the second line segment.\n * @param {Array} q2 The end vertex of the second line segment.\n * @return {Boolean} True if the two line segments intersect\n */\nfunction lineSegmentsIntersect(p1, p2, q1, q2){\n\tvar dx = p2[0] - p1[0];\n\tvar dy = p2[1] - p1[1];\n\tvar da = q2[0] - q1[0];\n\tvar db = q2[1] - q1[1];\n\n\t// segments are parallel\n\tif((da*dy - db*dx) === 0){\n\t\treturn false;\n\t}\n\n\tvar s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);\n\tvar t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);\n\n\treturn (s>=0 && s<=1 && t>=0 && t<=1);\n}\n\n/**\n * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.\n * @static\n * @method area\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @return {Number}\n */\nfunction triangleArea(a,b,c){\n    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));\n}\n\nfunction isLeft(a,b,c){\n    return triangleArea(a,b,c) > 0;\n}\n\nfunction isLeftOn(a,b,c) {\n    return triangleArea(a, b, c) >= 0;\n}\n\nfunction isRight(a,b,c) {\n    return triangleArea(a, b, c) < 0;\n}\n\nfunction isRightOn(a,b,c) {\n    return triangleArea(a, b, c) <= 0;\n}\n\nvar tmpPoint1 = [],\n    tmpPoint2 = [];\n\n/**\n * Check if three points are collinear\n * @method collinear\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.\n * @return {Boolean}\n */\nfunction collinear(a,b,c,thresholdAngle) {\n    if(!thresholdAngle){\n        return triangleArea(a, b, c) === 0;\n    } else {\n        var ab = tmpPoint1,\n            bc = tmpPoint2;\n\n        ab[0] = b[0]-a[0];\n        ab[1] = b[1]-a[1];\n        bc[0] = c[0]-b[0];\n        bc[1] = c[1]-b[1];\n\n        var dot = ab[0]*bc[0] + ab[1]*bc[1],\n            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),\n            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),\n            angle = Math.acos(dot/(magA*magB));\n        return angle < thresholdAngle;\n    }\n}\n\nfunction sqdist(a,b){\n    var dx = b[0] - a[0];\n    var dy = b[1] - a[1];\n    return dx * dx + dy * dy;\n}\n\n/**\n * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.\n * @method at\n * @param  {Number} i\n * @return {Array}\n */\nfunction polygonAt(polygon, i){\n    var s = polygon.length;\n    return polygon[i < 0 ? i % s + s : i % s];\n}\n\n/**\n * Clear the polygon data\n * @method clear\n * @return {Array}\n */\nfunction polygonClear(polygon){\n    polygon.length = 0;\n}\n\n/**\n * Append points \"from\" to \"to\"-1 from an other polygon \"poly\" onto this one.\n * @method append\n * @param {Polygon} poly The polygon to get points from.\n * @param {Number}  from The vertex index in \"poly\".\n * @param {Number}  to The end vertex index in \"poly\". Note that this vertex is NOT included when appending.\n * @return {Array}\n */\nfunction polygonAppend(polygon, poly, from, to){\n    for(var i=from; i<to; i++){\n        polygon.push(poly[i]);\n    }\n}\n\n/**\n * Make sure that the polygon vertices are ordered counter-clockwise.\n * @method makeCCW\n */\nfunction polygonMakeCCW(polygon){\n    var br = 0,\n        v = polygon;\n\n    // find bottom right point\n    for (var i = 1; i < polygon.length; ++i) {\n        if (v[i][1] < v[br][1] || (v[i][1] === v[br][1] && v[i][0] > v[br][0])) {\n            br = i;\n        }\n    }\n\n    // reverse poly if clockwise\n    if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {\n        polygonReverse(polygon);\n        return true;\n    } else {\n        return false;\n    }\n}\n\n/**\n * Reverse the vertices in the polygon\n * @method reverse\n */\nfunction polygonReverse(polygon){\n    var tmp = [];\n    var N = polygon.length;\n    for(var i=0; i!==N; i++){\n        tmp.push(polygon.pop());\n    }\n    for(var i=0; i!==N; i++){\n\t\tpolygon[i] = tmp[i];\n    }\n}\n\n/**\n * Check if a point in the polygon is a reflex point\n * @method isReflex\n * @param  {Number}  i\n * @return {Boolean}\n */\nfunction polygonIsReflex(polygon, i){\n    return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));\n}\n\nvar tmpLine1=[],\n    tmpLine2=[];\n\n/**\n * Check if two vertices in the polygon can see each other\n * @method canSee\n * @param  {Number} a Vertex index 1\n * @param  {Number} b Vertex index 2\n * @return {Boolean}\n */\nfunction polygonCanSee(polygon, a,b) {\n    var p, dist, l1=tmpLine1, l2=tmpLine2;\n\n    if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {\n        return false;\n    }\n    dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));\n    for (var i = 0; i !== polygon.length; ++i) { // for each edge\n        if ((i + 1) % polygon.length === a || i === a){ // ignore incident edges\n            continue;\n        }\n        if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) { // if diag intersects an edge\n            l1[0] = polygonAt(polygon, a);\n            l1[1] = polygonAt(polygon, b);\n            l2[0] = polygonAt(polygon, i);\n            l2[1] = polygonAt(polygon, i + 1);\n            p = lineInt(l1,l2);\n            if (sqdist(polygonAt(polygon, a), p) < dist) { // if edge is blocking visibility to b\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n/**\n * Check if two vertices in the polygon can see each other\n * @method canSee2\n * @param  {Number} a Vertex index 1\n * @param  {Number} b Vertex index 2\n * @return {Boolean}\n */\nfunction polygonCanSee2(polygon, a,b) {\n    // for each edge\n    for (var i = 0; i !== polygon.length; ++i) {\n        // ignore incident edges\n        if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b){\n            continue;\n        }\n        if( lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i+1)) ){\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Copy the polygon from vertex i to vertex j.\n * @method copy\n * @param  {Number} i\n * @param  {Number} j\n * @param  {Polygon} [targetPoly]   Optional target polygon to save in.\n * @return {Polygon}                The resulting copy.\n */\nfunction polygonCopy(polygon, i,j,targetPoly){\n    var p = targetPoly || [];\n    polygonClear(p);\n    if (i < j) {\n        // Insert all vertices from i to j\n        for(var k=i; k<=j; k++){\n            p.push(polygon[k]);\n        }\n\n    } else {\n\n        // Insert vertices 0 to j\n        for(var k=0; k<=j; k++){\n            p.push(polygon[k]);\n        }\n\n        // Insert vertices i to end\n        for(var k=i; k<polygon.length; k++){\n            p.push(polygon[k]);\n        }\n    }\n\n    return p;\n}\n\n/**\n * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.\n * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.\n * @method getCutEdges\n * @return {Array}\n */\nfunction polygonGetCutEdges(polygon) {\n    var min=[], tmp1=[], tmp2=[], tmpPoly = [];\n    var nDiags = Number.MAX_VALUE;\n\n    for (var i = 0; i < polygon.length; ++i) {\n        if (polygonIsReflex(polygon, i)) {\n            for (var j = 0; j < polygon.length; ++j) {\n                if (polygonCanSee(polygon, i, j)) {\n                    tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));\n                    tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));\n\n                    for(var k=0; k<tmp2.length; k++){\n                        tmp1.push(tmp2[k]);\n                    }\n\n                    if (tmp1.length < nDiags) {\n                        min = tmp1;\n                        nDiags = tmp1.length;\n                        min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);\n                    }\n                }\n            }\n        }\n    }\n\n    return min;\n}\n\n/**\n * Decomposes the polygon into one or more convex sub-Polygons.\n * @method decomp\n * @return {Array} An array or Polygon objects.\n */\nfunction polygonDecomp(polygon){\n    var edges = polygonGetCutEdges(polygon);\n    if(edges.length > 0){\n        return polygonSlice(polygon, edges);\n    } else {\n        return [polygon];\n    }\n}\n\n/**\n * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.\n * @method slice\n * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()\n * @return {Array}\n */\nfunction polygonSlice(polygon, cutEdges){\n    if(cutEdges.length === 0){\n\t\treturn [polygon];\n    }\n    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length===2 && cutEdges[0][0] instanceof Array){\n\n        var polys = [polygon];\n\n        for(var i=0; i<cutEdges.length; i++){\n            var cutEdge = cutEdges[i];\n            // Cut all polys\n            for(var j=0; j<polys.length; j++){\n                var poly = polys[j];\n                var result = polygonSlice(poly, cutEdge);\n                if(result){\n                    // Found poly! Cut and quit\n                    polys.splice(j,1);\n                    polys.push(result[0],result[1]);\n                    break;\n                }\n            }\n        }\n\n        return polys;\n    } else {\n\n        // Was given one edge\n        var cutEdge = cutEdges;\n        var i = polygon.indexOf(cutEdge[0]);\n        var j = polygon.indexOf(cutEdge[1]);\n\n        if(i !== -1 && j !== -1){\n            return [polygonCopy(polygon, i,j),\n                    polygonCopy(polygon, j,i)];\n        } else {\n            return false;\n        }\n    }\n}\n\n/**\n * Checks that the line segments of this polygon do not intersect each other.\n * @method isSimple\n * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]\n * @return {Boolean}\n * @todo Should it check all segments with all others?\n */\nfunction polygonIsSimple(polygon){\n    var path = polygon, i;\n    // Check\n    for(i=0; i<path.length-1; i++){\n        for(var j=0; j<i-1; j++){\n            if(lineSegmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){\n                return false;\n            }\n        }\n    }\n\n    // Check the segment between the last and the first point to all others\n    for(i=1; i<path.length-2; i++){\n        if(lineSegmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction getIntersectionPoint(p1, p2, q1, q2, delta){\n\tdelta = delta || 0;\n\tvar a1 = p2[1] - p1[1];\n\tvar b1 = p1[0] - p2[0];\n\tvar c1 = (a1 * p1[0]) + (b1 * p1[1]);\n\tvar a2 = q2[1] - q1[1];\n\tvar b2 = q1[0] - q2[0];\n\tvar c2 = (a2 * q1[0]) + (b2 * q1[1]);\n\tvar det = (a1 * b2) - (a2 * b1);\n\n\tif(!scalar_eq(det,0,delta)){\n\t\treturn [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det];\n\t} else {\n\t\treturn [0,0];\n    }\n}\n\n/**\n * Quickly decompose the Polygon into convex sub-polygons.\n * @method quickDecomp\n * @param  {Array} result\n * @param  {Array} [reflexVertices]\n * @param  {Array} [steinerPoints]\n * @param  {Number} [delta]\n * @param  {Number} [maxlevel]\n * @param  {Number} [level]\n * @return {Array}\n */\nfunction polygonQuickDecomp(polygon, result,reflexVertices,steinerPoints,delta,maxlevel,level){\n    maxlevel = maxlevel || 100;\n    level = level || 0;\n    delta = delta || 25;\n    result = typeof(result)!==\"undefined\" ? result : [];\n    reflexVertices = reflexVertices || [];\n    steinerPoints = steinerPoints || [];\n\n    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points\n    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars\n    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers\n    var lowerPoly=[], upperPoly=[]; // polygons\n    var poly = polygon,\n        v = polygon;\n\n    if(v.length < 3){\n\t\treturn result;\n    }\n\n    level++;\n    if(level > maxlevel){\n        console.warn(\"quickDecomp: max level (\"+maxlevel+\") reached.\");\n        return result;\n    }\n\n    for (var i = 0; i < polygon.length; ++i) {\n        if (polygonIsReflex(poly, i)) {\n            reflexVertices.push(poly[i]);\n            upperDist = lowerDist = Number.MAX_VALUE;\n\n\n            for (var j = 0; j < polygon.length; ++j) {\n                if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) { // if line intersects with an edge\n                    p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection\n                    if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) { // make sure it's inside the poly\n                        d = sqdist(poly[i], p);\n                        if (d < lowerDist) { // keep only the closest intersection\n                            lowerDist = d;\n                            lowerInt = p;\n                            lowerIndex = j;\n                        }\n                    }\n                }\n                if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n                    p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));\n                    if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {\n                        d = sqdist(poly[i], p);\n                        if (d < upperDist) {\n                            upperDist = d;\n                            upperInt = p;\n                            upperIndex = j;\n                        }\n                    }\n                }\n            }\n\n            // if there are no vertices to connect to, choose a point in the middle\n            if (lowerIndex === (upperIndex + 1) % polygon.length) {\n                //console.log(\"Case 1: Vertex(\"+i+\"), lowerIndex(\"+lowerIndex+\"), upperIndex(\"+upperIndex+\"), poly.size(\"+polygon.length+\")\");\n                p[0] = (lowerInt[0] + upperInt[0]) / 2;\n                p[1] = (lowerInt[1] + upperInt[1]) / 2;\n                steinerPoints.push(p);\n\n                if (i < upperIndex) {\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);\n                    polygonAppend(lowerPoly, poly, i, upperIndex+1);\n                    lowerPoly.push(p);\n                    upperPoly.push(p);\n                    if (lowerIndex !== 0){\n                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());\n                        polygonAppend(upperPoly, poly,lowerIndex,poly.length);\n                    }\n                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);\n                    polygonAppend(upperPoly, poly,0,i+1);\n                } else {\n                    if (i !== 0){\n                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());\n                        polygonAppend(lowerPoly, poly,i,poly.length);\n                    }\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);\n                    polygonAppend(lowerPoly, poly,0,upperIndex+1);\n                    lowerPoly.push(p);\n                    upperPoly.push(p);\n                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);\n                    polygonAppend(upperPoly, poly,lowerIndex,i+1);\n                }\n            } else {\n                // connect to the closest point within the triangle\n                //console.log(\"Case 2: Vertex(\"+i+\"), closestIndex(\"+closestIndex+\"), poly.size(\"+polygon.length+\")\\n\");\n\n                if (lowerIndex > upperIndex) {\n                    upperIndex += polygon.length;\n                }\n                closestDist = Number.MAX_VALUE;\n\n                if(upperIndex < lowerIndex){\n                    return result;\n                }\n\n                for (var j = lowerIndex; j <= upperIndex; ++j) {\n                    if (\n                        isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) &&\n                        isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))\n                    ) {\n                        d = sqdist(polygonAt(poly, i), polygonAt(poly, j));\n                        if (d < closestDist && polygonCanSee2(poly, i, j)) {\n                            closestDist = d;\n                            closestIndex = j % polygon.length;\n                        }\n                    }\n                }\n\n                if (i < closestIndex) {\n                    polygonAppend(lowerPoly, poly,i,closestIndex+1);\n                    if (closestIndex !== 0){\n                        polygonAppend(upperPoly, poly,closestIndex,v.length);\n                    }\n                    polygonAppend(upperPoly, poly,0,i+1);\n                } else {\n                    if (i !== 0){\n                        polygonAppend(lowerPoly, poly,i,v.length);\n                    }\n                    polygonAppend(lowerPoly, poly,0,closestIndex+1);\n                    polygonAppend(upperPoly, poly,closestIndex,i+1);\n                }\n            }\n\n            // solve smallest poly first\n            if (lowerPoly.length < upperPoly.length) {\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n            } else {\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n            }\n\n            return result;\n        }\n    }\n    result.push(polygon);\n\n    return result;\n}\n\n/**\n * Remove collinear points in the polygon.\n * @method removeCollinearPoints\n * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.\n * @return {Number}           The number of points removed\n */\nfunction polygonRemoveCollinearPoints(polygon, precision){\n    var num = 0;\n    for(var i=polygon.length-1; polygon.length>3 && i>=0; --i){\n        if(collinear(polygonAt(polygon, i-1),polygonAt(polygon, i),polygonAt(polygon, i+1),precision)){\n            // Remove the middle point\n            polygon.splice(i%polygon.length,1);\n            num++;\n        }\n    }\n    return num;\n}\n\n/**\n * Remove duplicate points in the polygon.\n * @method removeDuplicatePoints\n * @param  {Number} [precision] The threshold to use when determining whether two points are the same. Use zero for best precision.\n */\nfunction polygonRemoveDuplicatePoints(polygon, precision){\n    for(var i=polygon.length-1; i>=1; --i){\n        var pi = polygon[i];\n        for(var j=i-1; j>=0; --j){\n            if(points_eq(pi, polygon[j], precision)){\n                polygon.splice(i,1);\n                continue;\n            }\n        }\n    }\n}\n\n/**\n * Check if two scalars are equal\n * @static\n * @method eq\n * @param  {Number} a\n * @param  {Number} b\n * @param  {Number} [precision]\n * @return {Boolean}\n */\nfunction scalar_eq(a,b,precision){\n    precision = precision || 0;\n    return Math.abs(a-b) <= precision;\n}\n\n/**\n * Check if two points are equal\n * @static\n * @method points_eq\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Number} [precision]\n * @return {Boolean}\n */\nfunction points_eq(a,b,precision){\n    return scalar_eq(a[0],b[0],precision) && scalar_eq(a[1],b[1],precision);\n}\n","// @ts-ignore\nimport decomp from 'poly-decomp';\n\n// @ts-ignore\nwindow.decomp = decomp;\n"],"sourceRoot":""}